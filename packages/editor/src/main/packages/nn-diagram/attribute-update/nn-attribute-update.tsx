import React, { Component, ComponentClass, createRef } from 'react';
import styled from 'styled-components';
import { Button } from '../../../components/controls/button/button';
import { ColorButton } from '../../../components/controls/color-button/color-button';
import { TrashIcon } from '../../../components/controls/icon/trash';
import { Textfield } from '../../../components/controls/textfield/textfield';
import { Dropdown } from '../../../components/controls/dropdown/dropdown';
import { StylePane } from '../../../components/style-pane/style-pane';
import { DropdownButton } from '../../../components/controls/dropdown/dropdown-button';
import { DropdownMenu } from '../../../components/controls/dropdown/dropdown-menu';
import { connect } from 'react-redux';
import { compose } from 'redux';
import { UMLElementRepository } from '../../../services/uml-element/uml-element-repository';
import { ModelState } from '../../../components/store/model-state';
import { IConv1DAttribute, Conv1DAttribute } from '../nn-conv1d-attributes/conv1d-attributes';
import { IConv2DAttribute, Conv2DAttribute } from '../nn-conv2d-attributes/conv2d-attributes';
import { IConv3DAttribute, Conv3DAttribute } from '../nn-conv3d-attributes/conv3d-attributes';
import { IPoolingAttribute, PoolingAttribute } from '../nn-pooling-attributes/pooling-attributes';
import { IRNNAttribute, RNNAttribute } from '../nn-rnn-attributes/rnn-attributes';
import { ILSTMAttribute, LSTMAttribute } from '../nn-lstm-attributes/lstm-attributes';
import { IGRUAttribute, GRUAttribute } from '../nn-gru-attributes/gru-attributes';
import { ILinearAttribute, LinearAttribute } from '../nn-linear-attributes/linear-attributes';
import { IFlattenAttribute, FlattenAttribute } from '../nn-flatten-attributes/flatten-attributes';
import { IEmbeddingAttribute, EmbeddingAttribute } from '../nn-embedding-attributes/embedding-attributes';
import { IDropoutAttribute, DropoutAttribute } from '../nn-dropout-attributes/dropout-attributes';
import { ILayerNormalizationAttribute, LayerNormalizationAttribute } from '../nn-layernormalization-attributes/layernormalization-attributes';
import { IBatchNormalizationAttribute, BatchNormalizationAttribute } from '../nn-batchnormalization-attributes/batchnormalization-attributes';
import { ITensorOpAttribute, TensorOpAttribute } from '../nn-tensorop-attributes/tensorop-attributes';
import { IConfigurationAttribute, ConfigurationAttribute } from '../nn-configuration-attributes/configuration-attributes';
import { NNElementType } from '../index';

type TextfieldValue = string | number;

// Styled components
const Flex = styled.div`
  display: flex;
  align-items: baseline;
  justify-content: space-between;
`;

const AttributeInputContainer = styled.div`
  display: flex;
  align-items: center;
  flex-grow: 1;
  margin-right: 8px;
`;

const AttributeLabel = styled.span`
  font-family: inherit;
  font-size: inherit;
  color: inherit;
  margin-right: 4px;
  white-space: nowrap;
`;

const ValueTextfield = styled(Textfield)`
  flex-grow: 1;
  min-width: 60px;
`;

const MultiSelectContainer = styled.div`
  position: relative;
  flex-grow: 1;
`;

const CheckboxLabel = styled.label`
  display: flex;
  align-items: center;
  padding: 4px 8px;
  cursor: pointer;
  user-select: none;

  &:hover {
    background-color: rgba(0, 0, 0, 0.05);
  }

  input[type="checkbox"] {
    margin-right: 8px;
  }
`;

interface OwnProps {
  element: Conv1DAttribute | Conv2DAttribute | Conv3DAttribute | PoolingAttribute | RNNAttribute | LSTMAttribute | GRUAttribute | LinearAttribute | FlattenAttribute | EmbeddingAttribute | DropoutAttribute | LayerNormalizationAttribute | BatchNormalizationAttribute | TensorOpAttribute | ConfigurationAttribute;
}

interface StateProps {
  elements: ModelState['elements'];
}

interface DispatchProps {
  update: typeof UMLElementRepository.update;
  delete: typeof UMLElementRepository.delete;
}

type Props = OwnProps & StateProps & DispatchProps;

interface ComponentState {
  colorOpen: boolean;
  multiSelectOpen: boolean;
}

class NNAttributeUpdateComponent extends Component<Props, ComponentState> {
  state: ComponentState = { colorOpen: false, multiSelectOpen: false };
  multiSelectButtonRef = createRef<HTMLButtonElement>();

  private toggleColor = () => {
    this.setState((state) => ({
      colorOpen: !state.colorOpen,
    }));
  };

  private handleValueChange = (newValue: TextfieldValue) => {
    const { element, update } = this.props;
    update(element.id, {
      value: String(newValue),
      name: `${element.attributeName} = ${String(newValue)}`
    } as any);
  };

  // Special handler for Pooling dimension changes - updates kernel_dim and stride_dim
  private handleDimensionChange = (newValue: TextfieldValue) => {
    const { element, update, elements } = this.props;
    const dimensionValue = String(newValue);

    // Update the dimension attribute itself
    update(element.id, {
      value: dimensionValue,
      name: `${element.attributeName} = ${dimensionValue}`
    } as any);

    // Find sibling kernel_dim and stride_dim attributes
    const ownerId = element.owner;
    if (ownerId) {
      const siblingElements = Object.values(elements).filter(
        (el: any) => el.owner === ownerId
      );

      // Determine the correct list values based on dimension
      let kernelValue: string;
      let strideValue: string;
      switch (dimensionValue) {
        case '1D':
          kernelValue = '[3]';
          strideValue = '[1]';
          break;
        case '3D':
          kernelValue = '[3, 3, 3]';
          strideValue = '[1, 1, 1]';
          break;
        case '2D':
        default:
          kernelValue = '[3, 3]';
          strideValue = '[1, 1]';
          break;
      }

      // Update kernel_dim if it exists
      const kernelDimAttr = siblingElements.find(
        (el: any) => el.type === NNElementType.KernelDimAttributePooling
      );
      if (kernelDimAttr) {
        update(kernelDimAttr.id, {
          value: kernelValue,
          name: `kernel_dim = ${kernelValue}`
        } as any);
      }

      // Update stride_dim if it exists
      const strideDimAttr = siblingElements.find(
        (el: any) => el.type === NNElementType.StrideDimAttributePooling
      );
      if (strideDimAttr) {
        update(strideDimAttr.id, {
          value: strideValue,
          name: `stride_dim = ${strideValue}`
        } as any);
      }
    }
  };

  private handleDelete = () => {
    this.props.delete(this.props.element.id);
  };

  componentWillUnmount() {
    document.removeEventListener('click', this.dismissMultiSelect);
  }

  private toggleMultiSelect = (event: React.MouseEvent) => {
    event.stopPropagation();
    const newState = !this.state.multiSelectOpen;
    this.setState({ multiSelectOpen: newState });

    if (newState) {
      // Add listener when opening
      setTimeout(() => document.addEventListener('click', this.dismissMultiSelect), 0);
    } else {
      // Remove listener when closing
      document.removeEventListener('click', this.dismissMultiSelect);
    }
  };

  private dismissMultiSelect = () => {
    document.removeEventListener('click', this.dismissMultiSelect);
    this.setState({ multiSelectOpen: false });
  };

  private handleMetricsToggle = (option: string) => (event: React.ChangeEvent<HTMLInputElement>) => {
    const { element, update } = this.props;
    // Parse current values - handle both formats: "a, b" and "[a, b]"
    const rawValue = element.value || '';
    const cleanedValue = rawValue.replace(/^\[|\]$/g, ''); // Remove surrounding brackets if present
    const currentValues = cleanedValue ? cleanedValue.split(',').map(v => v.trim()) : [];

    let newValues: string[];
    if (event.target.checked) {
      // Add the option
      newValues = [...currentValues, option];
    } else {
      // Remove the option
      newValues = currentValues.filter(v => v !== option);
    }

    // Store value with brackets for List type
    const newValue = newValues.length > 0 ? `[${newValues.join(', ')}]` : '';
    update(element.id, {
      value: newValue,
      name: `${element.attributeName} = ${newValue}`
    } as any);
  };

  render() {
    const { element } = this.props;
    const { colorOpen } = this.state;

    // Check if this is the tns_type attribute for TensorOp
    const isTnsType = element.type === NNElementType.TnsTypeAttributeTensorOp;
    const tnsTypeOptions = ['reshape', 'concatenate', 'multiply', 'matmultiply', 'transpose', 'permute'];

    // Check if this is a padding_type attribute
    const isPaddingType = element.type === NNElementType.PaddingTypeAttributeConv1D ||
                          element.type === NNElementType.PaddingTypeAttributeConv2D ||
                          element.type === NNElementType.PaddingTypeAttributeConv3D ||
                          element.type === NNElementType.PaddingTypeAttributePooling;
    const paddingTypeOptions = ['valid', 'same'];
    // Handle legacy 'zeros' value by defaulting to 'valid'
    const paddingValue = isPaddingType && element.value === 'zeros' ? 'valid' : (element.value || 'valid');

    // Check if this is a pooling_type attribute
    const isPoolingType = element.type === NNElementType.PoolingTypeAttributePooling;
    const poolingTypeOptions = ['average', 'max', 'adaptive_average', 'adaptive_max', 'global_average', 'global_max'];

    // Check if this is a dimension attribute for Pooling or BatchNormalization
    const isDimension = element.type === NNElementType.DimensionAttributePooling ||
                        element.type === NNElementType.DimensionAttributeBatchNormalization;
    const dimensionOptions = ['1D', '2D', '3D'];
    // Handle legacy numeric value by defaulting to '2D'
    const dimensionValue = isDimension && !dimensionOptions.includes(element.value) ? '2D' : (element.value || '2D');

    // Check if this is an optimizer attribute
    const isOptimizer = element.type === NNElementType.OptimizerAttributeConfiguration;
    const optimizerOptions = ['sgd', 'adam', 'adamW', 'adagrad'];

    // Check if this is a loss_function attribute
    const isLossFunction = element.type === NNElementType.LossFunctionAttributeConfiguration;
    const lossFunctionOptions = ['crossentropy', 'binary_crossentropy', 'mse'];
    // Handle legacy 'cross_entropy' value by defaulting to 'crossentropy'
    const lossFunctionValue = isLossFunction && element.value === 'cross_entropy' ? 'crossentropy' : (element.value || 'crossentropy');

    // Check if this is a metrics attribute (multi-select)
    const isMetrics = element.type === NNElementType.MetricsAttributeConfiguration;
    const metricsOptions = ['accuracy', 'precision', 'recall', 'f1-score', 'mae'];
    // Parse metrics value - handle both formats: "a, b" and "[a, b]"
    const rawMetricsValue = element.value || '';
    const cleanedMetricsValue = rawMetricsValue.replace(/^\[|\]$/g, ''); // Remove surrounding brackets if present
    const selectedMetrics = cleanedMetricsValue ? cleanedMetricsValue.split(',').map(v => v.trim()) : [];
    const metricsDisplayValue = selectedMetrics.length > 0 ? `[${selectedMetrics.join(', ')}]` : 'Select metrics';

    // Check if this is an actv_func attribute
    const isActvFunc = element.type === NNElementType.ActvFuncAttributeConv1D ||
                       element.type === NNElementType.ActvFuncAttributeConv2D ||
                       element.type === NNElementType.ActvFuncAttributeConv3D ||
                       element.type === NNElementType.ActvFuncAttributePooling ||
                       element.type === NNElementType.ActvFuncAttributeRNN ||
                       element.type === NNElementType.ActvFuncAttributeLSTM ||
                       element.type === NNElementType.ActvFuncAttributeGRU ||
                       element.type === NNElementType.ActvFuncAttributeLinear ||
                       element.type === NNElementType.ActvFuncAttributeFlatten ||
                       element.type === NNElementType.ActvFuncAttributeEmbedding ||
                       element.type === NNElementType.ActvFuncAttributeLayerNormalization ||
                       element.type === NNElementType.ActvFuncAttributeBatchNormalization;
    const actvFuncOptions = ['relu', 'leaky_relu', 'sigmoid', 'softmax', 'tanh'];

    return (
      <>
        <Flex>
          <AttributeInputContainer>
            <AttributeLabel>{element.attributeName} = </AttributeLabel>
            {isTnsType ? (
              <Dropdown
                value={element.value || 'reshape'}
                onChange={this.handleValueChange}
                size="sm"
                outline
              >
                {tnsTypeOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : isPaddingType ? (
              <Dropdown
                value={paddingValue}
                onChange={this.handleValueChange}
                size="sm"
                outline
              >
                {paddingTypeOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : isPoolingType ? (
              <Dropdown
                value={element.value || 'max'}
                onChange={this.handleValueChange}
                size="sm"
                outline
              >
                {poolingTypeOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : isDimension ? (
              <Dropdown
                value={dimensionValue}
                onChange={element.type === NNElementType.DimensionAttributePooling
                  ? this.handleDimensionChange
                  : this.handleValueChange}
                size="sm"
                outline
              >
                {dimensionOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : isOptimizer ? (
              <Dropdown
                value={element.value || 'adam'}
                onChange={this.handleValueChange}
                size="sm"
                outline
              >
                {optimizerOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : isLossFunction ? (
              <Dropdown
                value={lossFunctionValue}
                onChange={this.handleValueChange}
                size="sm"
                outline
              >
                {lossFunctionOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : isMetrics ? (
              <MultiSelectContainer onClick={(e) => e.stopPropagation()}>
                <DropdownButton
                  ref={this.multiSelectButtonRef}
                  color="primary"
                  onClick={this.toggleMultiSelect}
                  outline={true}
                  size="sm"
                >
                  {metricsDisplayValue}
                </DropdownButton>
                {this.state.multiSelectOpen && this.multiSelectButtonRef.current && (
                  <DropdownMenu
                    style={{
                      position: 'absolute',
                      top: this.multiSelectButtonRef.current.getBoundingClientRect().height,
                      left: 0,
                      minWidth: this.multiSelectButtonRef.current.getBoundingClientRect().width,
                      zIndex: 1000,
                    }}
                  >
                    {metricsOptions.map(option => (
                      <CheckboxLabel key={option} onClick={(e) => e.stopPropagation()}>
                        <input
                          type="checkbox"
                          checked={selectedMetrics.includes(option)}
                          onChange={this.handleMetricsToggle(option)}
                          onClick={(e) => e.stopPropagation()}
                        />
                        {option}
                      </CheckboxLabel>
                    ))}
                  </DropdownMenu>
                )}
              </MultiSelectContainer>
            ) : isActvFunc ? (
              <Dropdown
                value={element.value || 'relu'}
                onChange={this.handleValueChange}
                size="sm"
                outline
              >
                {actvFuncOptions.map(option => (
                  <Dropdown.Item key={option} value={option}>
                    {option}
                  </Dropdown.Item>
                ))}
              </Dropdown>
            ) : (
              <ValueTextfield
                gutter
                value={element.value || ''}
                onChange={this.handleValueChange}
                placeholder="value"
              />
            )}
          </AttributeInputContainer>
          <ColorButton onClick={this.toggleColor} />
        </Flex>
        <StylePane open={colorOpen} element={element} onColorChange={this.props.update} fillColor textColor />
      </>
    );
  }
}

const mapStateToProps = (state: ModelState): StateProps => ({
  elements: state.elements,
});

const enhance = compose<ComponentClass<OwnProps>>(
  connect<StateProps, DispatchProps, OwnProps, ModelState>(
    mapStateToProps,
    {
      update: UMLElementRepository.update,
      delete: UMLElementRepository.delete,
    },
  ),
);

export const NNAttributeUpdate = enhance(NNAttributeUpdateComponent);
